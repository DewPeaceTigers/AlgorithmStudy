# 대표적 그래프 탐색 알고리즘

탐색이란 "원하는 데이터를 찾는 과정"을 의미함

- 그래프

  정점과 그 정점을 연결하는 간선으로 이루어진 자료구조의 일종

  그래프를 탐색하는 것은 하나의 정점으로부터 시작해 차례대로 모든 정점을 한번씩 방문하는 것

  > 💡 DFS & BFS 를 이해하기 위해서는 그래프에 대해서 알아야 한다!

#### 그래프 기본 구조
그래프는 **노드(Node)**와 **간선(Edge)**으로 표현됨
- 노드 : **정점(Vertex)**이라고도 함
- '두 노드는 인접하다' : 두 노드가 간선으로 연결되어 있다.

#### 그래프 탐색
하나의 노드를 시작으로 다수의 노드를 방문하는 것

#### 그래프 표현 방식
- 인접 행렬(Adjacency Matrix)
  - 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  - 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비됨

- 인접 리스트(Adjacency List)
  - 리스트로 그래프의 연결 관계를 표현하는 방식
  - 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용
  - 연결된 데이터를 하나씩 확인해야 하기 때문에 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림

# 깊이 우선 탐색(DFS)
루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법이다. 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.
>사용하는 경우
>
>  모든 노드를 방문하고자 하는 경우에 이 방법을 선택한다

### 동작 과정
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.

2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

### 특징
- 자기 자신을 호출하는 순환 알고리즘의 형태를 가지고 있다
- 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다. 검사하지 않을 경우 무한루프에 빠질 위험이 있다.
- 스택이나 재귀함수로 구현한다.

### 장/단점
- 장점
  - 현재 경로상의 노드들만 기억하면 되므로, 저장 공간의 수요가 비교적 적다
  - 목표 노드가 깊은 단계에 있는 경우 해를 빨리 구할 수 있다
  - 구현이 BFS보다 간단하다
- 단점
  - 단순 검색 속도가 BFS보다 느리다
  - 깊이 우선 탐색은 해를 구하면 탐색이 종료되므로, 구한 해가 최단 경로가 된다는 보장이 없다
  
### 시간복잡도
- 인접리스트 : O(V+E) (V : 정점의 개수, E : 간선의 개수)
  - 한번 방문한 지점은 다시 방문하지 않는다
  - 하나의 정점에서 다음으로 방문할 정점들을 순회하는 횟수가 그 정점의 간선의 개수와 같기 때문이다
- 인접행렬 : O(V^2) (V: 정점의 개수)
  - DFS를 호출하는 회수 V
  - 다음 방문할 정점을 찾을 때 모든 정점을 순회하며 두 정점이 연결되어 있는지 확인해야 하기 때문이다

### 구현

- 스택 구현
```python
def dfs(graph, start_node):
    visit = list()
    stack = list()

    stack.append(start_node)

    while stack:
        node = stack.pop()
        if node not in visit:
            visit.append(node)
            stack.extend(graph[node])

    return visit
```
- 재귀 구현
```python
def dfs_recursive(v,discovered=[]):
	discovered.append(v)
    for w in graph[v]:
    	if w not in discovered:
        	discovered=dfs(w,discovered)
        return discovered
```

# 너비우선탐색(BFS)
루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
> 사용하는 경우
>
>두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때

### 동작 과정
1. 탐색 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행 할 수 없을 때까지 반복한다.

### 특징
- 재귀적으로 동작하지 않는다
- 어떤 노드를 방문했었는지 여부를 검사해야한다. 검사하지 않을 경우 무한 루프에 빠질 위험이 있다
- 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료구조인 큐(Queue)를 주로 사용한다.

### 장/단점
- 장점
  - 노드의 수가 적고 깊이가 얕은 경우 빠르게 동작할 수 있다
  - 단순 검색 속도가 DFS보다 빠르다
  - 너비를 우선으로 탐색하기 때문에 답이 되는 경로가 여러개인 경우에도 최단 경로를 보장한다
- 단점
  - 재귀적으로 동작하지 않기 때문에 저장공간이 많이 필요하다
  - 해가 존재하지 않는 유한 그래프 경우, 탐색 후 실패로 끝난다.
  - 무한 그래프의 경우 해를 찾지도 못하고 끝내지도 못한다.
### 구현
```python
def bfs(graph, start_node):
    visit = list()
    queue = list()

    queue.append(start_node)

    while queue:
        node = queue.pop(0)
        if node not in visit:
            visit.append(node)
            queue.extend(graph[node])

    return visit
```
### 시간 복잡도
BFS와 동일하다

# 문제 유형
1. 모든 정점을 방문하는 것이 주요 문제 ➡️ dfs,bfs
2. 경로의 특징을 저장할 필요가 있는 문제 ➡️ dfs
   
    bfs는 경로의 특징을 갖지 못한다.

3. 최단 거리 구하기 ➡️ bfs 유리

    dfs는 처음 발견하는 해답이 최단 거리가 아닐 수 있음
 
   bfs는 현재 노드에서 가장 가까운 곳부터 찾기에 먼저 나오는 것이 곧 최단 거리

4. 검색 대상 그래프가 크다면 ➡️ dfs

5.  규모가 크지 않고 원하는 대상이 멀지 않다면 ➡️ bfs

[출처]
https://itholic.github.io/python-bfs-dfs/