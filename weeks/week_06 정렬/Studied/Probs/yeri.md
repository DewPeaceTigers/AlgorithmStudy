## 예리

1. 상황과 관계없이 시간 복잡도가 동일한 1가지 알고리즘은?

   선택 정렬

2. 데이터의 개수가 적을 때 가장 좋은 알고리즘은?

   선택 정렬

3. 분할 정복을 사용하는 2가지 알고리즘은?

   합병 정렬, 퀵 정렬

4. 2번의 알고리즘들이 갖는 시간 복잡도에 대해 설명하시오

   o(nlogn)으로 분할시 갖게 되는 단계의 수는 log2n 이고, 단계마다 데이터 정렬시 비교 횟수가 n개 이므로 평균적으로 nlogn의 시간복잡도를 갖는다. 최악의 경우 n개의 단계가 생겨 O(n^2)이 된다.

5. 합병 정렬과 퀵 정렬의 차이점은?

   합병 정렬은 합치면서 정렬을 하고, 퀵 정렬은 나누면서 정렬을 한다.

### 민지

1. 선택정렬, 삽입정렬, 버블정렬, 합병 정렬의 시간 복잡도

   O(n^2), O(n^2), O(nlogn), O(nlogn)

2. 합병정렬 과정 설명

   1. 리스트를 반으로 나눈다.
   2. 각 데이터가 1이 되면 합치기 시작한다.
   3. 왼쪽의 작은 것과 오른쪽의 작은 것을 비교하여 순서대로 배치한다.

3. 합병정렬과 퀵정렬은 **\_** 방식을 이용해 설계된 알고리즘이다.

   분할 정복

4. 선택 정렬의 시간복잡도와 이유 설명

   O(n^2), i번째를 제외한 i+1~n-1까지의 데이터를 비교하여 가장 작은 것을 i+1 위치에 배치하므로 n(n-1)/2의 비교를 하게 된다.

5. 퀵정렬은 최선의 경우 시간 복잡도는 \_**\_이고 최악의 경우 시간 복잡도는 \_\_\_**이다.

   O(nlogn), O(n^2)

## 정민

1. 이미 데이터가 정렬되어 있는 경우 빠르게 동작하는 정렬 알고리즘

   버블 정렬

2. 퀵 정렬에서 평균/최악의 시간 복잡도와 어떠한 경우가 최악이 되는지

   평균 : O(nlogn)
   최악 : 단계의 수가 n이 될 때, 즉 모든 숫자가 역순으로 배치돼있을 경우

3. 아래 퀵정렬 소스코드에서 빈칸을 채우세요. (퀵 정렬이 끝나는 조건)
   ```python
   def quick_sort(arr):
       # 재귀 함수 종료 조건
       __________________
       __________________

       pivot = arr[0]
       tail = arr[1:]

       left_side = [x for x in tail if x<=pivot]
       right_side = [x for x in tail if x>pivot]

       return quick_sort(left_side) + [pivot] + quick_sort(right_side)
   ```
   ```python
   if len(arr)<=1:
       return arr
   ```
4. 분할 정복(Divide and Conquer) 방식을 사용한 정렬 알고리즘 2가지

   예리 3

5. 삽입 정렬의 수행 과정을 설명하세요.

   1. i 번째를 제외한 i+1~n-1 데이터 중 최소값을 찾음
   2. 해당 최소값을 i+1에 위치
   3. i+1을 제외한 나머지에 대해 동일한 과정 반복
