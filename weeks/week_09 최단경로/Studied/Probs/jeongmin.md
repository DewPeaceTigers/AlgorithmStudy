## 정민

1. 다익스트라 알고리즘과 벨만포드 알고리즘의 차이점

    - 다익스트라 알고리즘은 가중치가 음수인 경우는 처리 못하지만, 벨만 포드 알고리즘은 가중치가 음수인 경우도 처리가능하다는 점이다.

2. 다익스트라 알고리즘에서 시간복잡도는?

    - 우선순위 큐를 이용하지 않고 매번 가장 짧은 거리를 가지는 노드를 찾아서 구현하는 방식:  O(V^2)
    - 우선순위 큐를 이용: O(ElogV)
        - 우선순위 큐에서 꺼낸 현재 노드에 연결된 간선 모두 확인 - 간선의 개수(E) 만큼 확인
        - 우선순위 큐에 간선을 넣고 빼는 과정 - logE
        - 따라선 모든 간선을 우선순위 큐에 넣고 뺀다고 했을 때 O(ElogE) 의 시간 복잡도를 갖는다.
        - 이때, 중복 간선을 포함하지 않는 경우, E는 항상 V^2 이하이다. (모든 노드가 연결 되어 있는 경우 V * (V-1))
        - logE < log(V^2)이다. log(V^2)은 2logV이기 때문에 O(logV)로 표현할 수 있다.
        - 따라서, 다익스트라 알고리즘 전체 시간 복잡도를 O(ElogV) 로 표현할 수 있다. (ElogE)

3. 플로이드 워셜 알고리즘이 최단거리를 갱신할 때 사용하는 점화식은?

    - Dab = min(Dab, Dak + Dkb)

4. 다익스트라 알고리즘이 그리디 알고리즘으로 분류되는 이유

    - 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택'하는 과정을 반복

5. 벨만-포드 알고리즘의 구현 코드입니다. 빈칸을 채워주세요.

    ```python
    def bf(start):
        # 시작 노드에 대해서 초기화
        dist[start] = 0

        # 전체 n번의 라운드(round)를 반복
        for i in range(n):
            # 매 반복마다 '모든 간선'을 확인하며
            for cur in range(n):
                for (next_node, cost) in graph[cur]:
                    # 현재 간선을 거쳐서 다른 노드로 이동하는 거리가 더 짧을 경우
                    if dist[cur] != INF and dist[next_node] > dist[cur] + cost:
                        dist[next_node] = dist[cur] + cost

                        # 음수 순환이 존재하는 경우 판별
                        if i == n-1:
                            return True

        return False
    ```