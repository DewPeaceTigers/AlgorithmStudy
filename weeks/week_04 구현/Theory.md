# 구현 : 완전 탐색
빠른 계산 능력을 이용하여 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법
Brute-Force 라고도 부름. 문제 푸는 '방법'이다.

> 효율성  
Computer Science에서 문제 해결 알고리즘을 사용할 때는 2가지 규칙이 적용된다.
>1. 사용된 알고리즘이 적절한가?
>2. 효율적으로 동작하는가?
>
>완전 탐색 알고리즘은 1번은 만족하지만 대부분의 경우 2번을 만족하지 못하기 때문에 제한이 따른다. 시간 복잡도를 생각하면 완전탐색 알고리즘을 사용할 경우 모든 문제에 대한 경우의 수가 적을 경우 적절하다.

## 동작 과정
1. 해결하고자 하는 문제의 가능한 경우의 수를 대략적으로 계산
2. 가능한 모든 방법을 다 고려
3. 실제 답을 구할 수 있는지 적용

## 종류
### 순열 Permutation
완전 탐색의 대표적 유형. N!의 시간이 필요하기에 N이 한자리 수 일때만 완전탐색으로 할 수 있음  
임의의 수열이 주어졌을 때 그것을 다른 순서로 연산하는 방법이다. 서로 다른 N개를 일렬로 나열하는 순열의 경우의 수는 N!이므로 완전 탐색을 이용하기 위해서는 N이 한자리 수 정도여야 한다. 

### 비트마스크
2진수를 이용하는 컴퓨터 연산을 이용하는 방식
문제에서 나올 수 있는 모든 경우의 수가 각각의 원소가 포함 되거나 포함되지 않는 두가지 선택으로 구성되는 경우 유용하게 사용 가능 

비트연산(AND, OR, XOR, SHIFT, NOT)을 이용하는 방식이다. 
  모든 경우의 수가 각각의 원소에 포함되거나 포함되지 않는 두가지 선택으로 구성되는 경우에 유용하게 사용이 가능하다. 숫자를 2진수로 변환하여 부분집합에 어떤 원소들을 포함하고 있는지 나타낼 수 있다. 
  > S = {1, 3, 4, 7, 10} 이 있는 경우 5자리 이진수를 이용하여 각 원소의 포함 여부를 체크할 수 있다.
  - 부분집합이 {4, 10}일 경우 3번째와 5번째 원소를 갖고 있으므로 5=101(2)
  - {1, 3, 4, 7, 10}일 경우는 1~5번째 원소를 모두 갖고 있으므로 31=11111(2)로 나타낼 수 있다. 

### 재귀
문제를 만족하는 경우들을 만들어가는 방식
포함되거나 포함되지 않거나 두가지 선택을 가질 때 사용한다.

재귀는 자기 자신을 호출하는 것이다. 
  > 중요
  - 자기 자신을 호출하기 때문에 빠져나오기 위한 탈출 조건이 필요
  - 현재 함수의 상태를 저장하는 전달인자가 필요
  - return문을 신경써야 한다.
    이전 결과에 추가 연산을 수행해야할 경우는 연산 결과를 반환해야하기 때문이다
  
  예시) 피보나치 수열
  
  ``` python
  def Fibo(n) :
  	if n<=1 :
    	return n
    else :
    	return fibo(n-1)+fibo(n-2)
  
  ```

### Brute Force 
반복/ 조건문을 통해 가능한 모든 case를 만들어 답을 구하는 방법

### 브루트포스 (brute force) 란?
- **완전탐색** 알고리즘
- **모든 경우의 수를 탐색**하면서 요구조건에 충족되는 결과만 가져옴
- 브루트포스 알고리즘을 설계할 때는 '해가 하나 이상 존재한다'는 가정을 세우고 모든 범위를 탐색하기 때문에 무조건 정답을 찾을 수 있다.
- 전체를 탐색하기 위해 탐색 알고리즘을 사용한다. 순차탐색, dfs, bfs를 도구로 이용

### 장단점
- 장점
  - 알고리즘을 설계하고 구현하기 쉽고, 100%의 정답률을 가진다.
- 단점
  - 알고리즘의 실행 시간이 오래 걸린다.

### 구조에 따른 브루트포스 종류
- 선형 구조 : 순차 탐색
- 비선형 구조 : BFS(너비 우선 탐색), DFS(깊이 우선 탐색)

### 순차 탐색 방법
1. 문제에서 주어진 자료를 선형 구조로 구조화한다. (구조화)
2. 구조화된 자료들을 구조에 맞는 방법으로 해를 구할 때까지 탐색한다. (탐색)
3. 탐색한 해를 주어진 문제의 출력 형식에 맞게 정리한다. (정리)

### BFS/DFS
길 찾기 문제. 주로 완전탐색 + DFS/BFS 문제가 많이 나옴
조건을 처리할 추가적인 작업이 필요한 경우에 완전탐색으로 해결한 후에 이 방법을 적용하게 됨

### BFS
- 너비 우선 탐색, 가까운 노드부터 탐색하는 알고리즘
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드부터 방문하는 방법
![](https://images.velog.io/images/ryujm/post/e61b0afa-0869-4bed-8c02-21f67b71cb13/bfs.png)

### DFS
- 깊이 우선 탐색, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법 (자식들을 우선적으로 탐색하는 방법)
![](https://images.velog.io/images/ryujm/post/162d2329-d2a2-4c16-b1cf-6042cdf636c0/dfs.png)

>  BFS & DFS 는 나중에 자세히 정리할 예정이다! [참조블로그](https://velog.io/@ming/DFS-vs-BFS-%ED%83%90%EC%83%89)

### 백트래킹 (backtracking) 이란?
- **"가능한 모든 방법을 탐색한다"**의 아이디어를 가진다.
- 해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 해를 다시 찾는 기법
- **가지치기(pruning)**를 얼마나 잘하느냐에 따라 효율성이 결정되게 됨
  - 가지치기(pruning) : 불필요한 부분을 쳐내고 최대한 올바른 쪽으로 간다.

### DFS vs 백트래킹
- DFS
  - 가능한 모든 경로(후보)를 탐색
  - 불필요할 것 같은 경로를 사전에 차단하지 않으므로 경우의 수를 줄이지 못한다.
- 백트래킹
  - 가능한 모든 경로(후보) 중에서 특정한 조건을 만족하는 경우만 살펴보는 것
  - 해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더 이상 가지 않고 되돌아간다.
  - DFS에 가지치기(pruning)를 통해 가도되지 않는 루트는 고려하지 않고 탐색하는 완전탐색 기법
  
### 문제 해결 방법
1. 상태 공간 트리의 깊이 우선 검색(DFS)을 실시함.
2. 각 노드가 유망한지(promising)를 점검
3. 해당 노드가 유망하지 않다면 부모로 돌아가서 검색을 계속함(Backtracking)
> 해가 될 가능성이 있으면 **유망하다(promising)** 고 하며,
유망하지 않은 노드에 가지 않는 것을 **가지치기(pruning)** 한다고 한다.

✔ 주로 문제 풀이에서는 DFS 등으로 모든 경우의 수를 탐색하는 과정에서, 조건문 등을 걸어 답이 절대로 될 수 없는 상황을 정의하고, 그러한 상황일 경우에는 탐색을 중지시킨 뒤 그 이전으로 돌아가서 다시 다른 경우를 탐색하게끔 구현할 수 있다.

### 예제) [N과 M(1)](https://www.acmicpc.net/problem/15649)
1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
```python
import sys
input = sys.stdin.readline

# 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
# 고른 수열은 오름차순
N, M = map(int, input().split())

s=[]

# 백트래킹 이용
def dfs():
  if len(s)==M:
    print(*s) # 공백으로 구분해서 출력
    return
  for i in range(1, N+1):
    # 중복 없게
    if i not in s:
      s.append(i)
      dfs()
      s.pop()

dfs()
```
1. s 리스트에 수열 저장
2. 리스트에 들어간 수열들이 m개가 되면 리스트 원소들을 모두 출력하고 함수 리턴
3. 1부터 N까지의 자연수 중 선택
    - 선택한 숫자를 다시 선택하려 하면(중복) 배제하는 방식으로 가지치기
    - 중복이 아니라면 해당 숫자를 s리스트에 추가하고, dfs() 호출, 동작이 끝난 후에는 s.pop() 수행

### 예제) **N Queen** 대표적인 백트래킹 문제
N*N 체스판에 N개의 퀸을 서로 공격할 수 없도록 배치
- Pruning
  - 한 행에 하나의 퀸
  - 맨 위 행부터 퀸 배치, 다음 행에 이동할 수 없는 위치를 찾아 퀸 배치
  - 앞선 행에 배치된 퀸에 의해 다음 행에 퀸들이 이동할 수 없는 위치일 겨우 더이상 그 퀸 배치를 이용하지 않고, 그 행의 퀸 배치를 바꿈
- Promising
  - 해당 루트가 조건에 맞는 지 검사하는 기법
  - 여태 배치된 퀸이 이동할 수 없는 위치가 있는지를 조건으로 확인
    - 수직 체크 : 같은 열 다른 행 확인
    - 대각선 체크 : 열 Gap == 행 Gap 일 경우
    - 수평 체크는 한 행에 하나의 퀸만 고르면서 해결했음

[절차]

1. DFS 수행
2. 유망한 노드 검토 
방문한 노드를 포함해서 유망한 노드이면 서브트리로 이동, 그렇지 않으면 백트래킹 수행

```python
n=int(input())
def is_available(candidate, current_col):
    current_row = len(candidate)
    for queen_row in range(current_row):
        if candidate[queen_row] == current_col or abs(candidate[queen_row] - current_col) == current_row - queen_row:
            # 수직 체크 : 같은 열에 있는지 없는지 / 대각선 체크 : 열 차이와 행 차이가 같으면 대각선에 위치한 것임
            return False
    return True


def DFS(N, current_row, current_candidate, final_result):
    if current_row == N: # n 행에 모든 queen을 찾았을 때
        final_result.append(current_candidate[:]) # [:] 얕은 복사
        return

    for candidate_col in range(N):
        if is_available(current_candidate, candidate_col): # 현재 행의 한 칸이 괜찮은지
            current_candidate.append(candidate_col) # 괜찮으므로 후보에 추가하고
            DFS(N, current_row + 1, current_candidate, final_result) # 다음 행으로 넘어가기
            current_candidate.pop() # 방금 후보 지우기


def solve_n_queens(N):
    final_result = []
    DFS(N, 0, [], final_result)
    return len(final_result)

print(solve_n_queens(n))
```

### 실전 이용 예시
1. 입력으로 주어지는 데이터의 크기가 매우 작을 경우
2. 답의 범위가 작고, 임의의 답을 하나 선택시 문제 조건을 만족하는지 역추적 가능
3. 여러 문제 조건 중 한 조건을 고정시키면 문제 풀이가 간단해진다.


